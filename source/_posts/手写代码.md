---
title: 前端手写代码
date: 2025-09-08 10:00:00
tags:
    - 前端
    - 手写代码
---
## 手写代码

### 手写vue的reactive响应式

```javascript
// 依赖跟踪系统
const targetMap = new WeakMap(); // 存储 target -> key -> effects 的映射

let activeEffect = null; // 当前激活的副作用函数

/**
 * 副作用函数包裹器
 * @param {Function} fn - 需要响应式执行的函数
 */
function effect(fn) {
  const runner = () => {
    activeEffect = runner;
    return fn(); // 执行副作用函数
  };
  runner(); // 立即执行一次
  return runner;
}

/**
 * 依赖收集（track）
 * @param {Object} target - 目标对象
 * @param {string|Symbol} key - 属性名
 */
function track(target, key) {
  if (!activeEffect) return;

  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }

  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }

  if (!dep.has(activeEffect)) {
    dep.add(activeEffect); // 收集当前副作用函数
  }
}

/**
 * 触发更新（trigger）
 * @param {Object} target - 目标对象
 * @param {string|Symbol} key - 属性名
 */
function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;

  const effects = depsMap.get(key);
  if (effects) {
    effects.forEach(effect => effect()); // 执行所有依赖的副作用函数
  }
}

/**
 * 创建响应式对象（reactive）
 * @param {Object} target - 普通对象
 * @returns {Proxy} - 响应式代理对象
 */
function reactive(target) {
  // 如果已经是响应式对象，直接返回
  if (target && target.__isReactive) return target;

  // 创建 Proxy 代理
  const proxy = new Proxy(target, {
    get(target, key, receiver) {
      const result = Reflect.get(target, key, receiver);

      // 依赖收集
      track(target, key);

      // 递归处理嵌套对象
      if (typeof result === "object" && result !== null) {
        return reactive(result); // 深度代理
      }

      return result;
    },
    set(target, key, value, receiver) {
      const oldValue = target[key];
      const result = Reflect.set(target, key, value, receiver);

      // 如果值未改变，不触发更新
      if (oldValue === value) return result;

      // 触发更新
      trigger(target, key);
      return result;
    },
  });

  // 标记为响应式对象
  proxy.__isReactive = true;
  return proxy;
}
```

### 手写Object.Create

```javascript
function myCreate(obj) {
    function F() {};
    F.prototype = obj;
    return new F();
}
```

### 手写 instanceOf

```javascript
function myInstanceOf(construtor, obj) {
    let proto = Object.getPrototypeOf(obj);
    while(proto) {
        if (construtor === proto) {
            return true;
        }
        proto = Object.getPrototypeOf(proto);
    }
    return false;
}
```

### 手写 new

```javascript
function myNew(obj, ...rest) {
    const newObj = Object.create(obj.prototype);
    const res = obj.call(newObj, ...rest);
    return (typeof res === 'object' && typeof result !== null) ? res : newObj;
}
```

### 手写 Promise.all

```javascript
function promiseAll(promises) {
    return new Promise((resolve, reject) => {
        let count = 0;
        const len = promises.length;
        let res = [];
        promises.forEach(promise => {
            Promise.resolve(promise).then((result) => {
                res[count] = result;
                count++;
                if (count === len) {
                    resolve(res);
                }
            }, rej => {
                reject(rej);
            })
        });
    })
}
```

### 手写 Promise.allSettled

不管是什么都存起来 最终返回

### 手写防抖节流

```javascript
// 防抖
function debounce(fn, delay) {
    let timer;
    return function(...args) {
        if(timer) {
            clearTimeout(timer);
            timer = null;
        };
        timer = setTimeout(() => {
            fn(...args)
            timer = null;
        }, delay)
    }
}
// 节流
function throttle(fn, wait) {
    let time = new Date();
    return function(...args) {
        let cur = new Date();
        let context = this;
        if (cur - time >= wait) {
            fn.appply(context, ...args);
            time = new Date();
        }
    }
}
```

### 手写 call、apply、bind

```javascript
Function.prototype.mycall = function(context, ...args) {
    context = context || window;
    let symbol = new Symbol('call');
    context[symbol] = this;
    const res = context[symbol](...args);
    delete context[symbol]
    return res;
}
```

### 手写千分位

```javascript
function formatterNumber(num) {
	let tempStr = num.toString();
	let isNegative = false;
	if (tempStr.startsWith('-')) {
		isNegative = true;
        tempStr = tempStr.slice(1);
	}
    const [integerPart, decimalPart] = tempStr.split('.');
    let parts = [];
    for (let i = integerPart.length; i > 0; i -= 3) {
        const start = Math.max(0, i - 3);
        parts.unshift(integerPart.slice(start, i));
    }
    let res = [parts.join(',')];
    decimalPart&&res.push(decimalPart);
    if (isNegative) {
        return `-${res.join('.')}`;
    }
    return res.join('.');
}
```

