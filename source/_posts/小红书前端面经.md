---
title: 小红书前端面经
date: 2025-09-08 21:32:24
tags:
    - 前端
    - 面经
    - 小红书
---

1.  在线协同作业，怎么保证用户操作的一致性？
    OT操作，原子化，如果A用户删除、B用户编辑了同一段文本，可以考虑以删除为高优先级的操作。

2.  如果在一个几十万节点的树状svg中需要展开显示树最深层节点，应该怎么实现？
    1.  用viewBox进行分页
    2.  初始化渲染时filter出viewBox范围内的节点并展示
    3.  或者更改viewbox的值，会自动展示出该区域的图形。

3.  访问者模式的优缺点。有什么经典的前端场景用到了访问者模式
    1.  优点：针对同个数据类型的扩展接入即可使用。逻辑跟渲染分离。
    2.  缺点：如果数据类型改变，所有访问者类都需要更改。
    3.  AST树的babel转换。
        抽象语法树（AST）的处理 - 最经典的案例
        这是访问者模式在前端最强大、最普遍的应用场景。几乎所有的主流工具都依赖于对 AST 的遍历和修改。
        *   **场景**：Babel、ESLint、Prettier、Webpack、TypeScript Compiler 等工具的核心。
        *   **数据结构**：AST（你的代码被解析后形成的树状结构）。这个结构非常稳定，节点类型（如 `FunctionDeclaration`, `VariableDeclarator`, `IfStatement`）是固定的。
        *   **访问者**：Babel 插件、ESLint 规则、Prettier 的格式化器。
        *   **如何工作**：
            1.  工具（如 Babel）将源代码解析成 AST。
            2.  你提供的“访问者”对象被传递给遍历器。这个对象的属性名是 AST 节点类型（如 `Identifier`, `CallExpression`），属性值是处理这些节点的函数。
            3.  遍历器会按照某种顺序（深度优先）遍历 AST 的每一个节点。
            4.  每当遇到一个节点类型与访问者对象中的属性名匹配时，就调用该属性对应的函数，并将当前节点作为参数传入。

4.  websocket跟http的区别
    1.  websocket 全双工，可以互发消息
    2.  http每次请求都会有请求头，开销大
    3.  http只能通过轮询获得服务器消息
    4.  http的主动推送也跟websocket的服务器发消息不同

5.  音视频通信的流程（webRTC）
    1.  媒体流采集
        浏览器通过 getUserMedia() 获取本地音视频流。
    2.  信令交换
        1.  浏览器 A 创建 RTCPeerConnection 并生成 Offer SDP，通过 WebSocket 发送给服务器。
        2.  服务器将 Offer 转发给浏览器 B。
        3.  浏览器 B 创建 RTCPeerConnection，接收 Offer 并生成 Answer SDP，通过 WebSocket 发送给服务器。
        4.  服务器将 Answer 转发给浏览器 A
    3.  ICE 候选交换
        *   浏览器 A/B 通过 onicecandidate 事件收集本地 ICE 候选（如 STUN 服务器地址），并通过 WebSocket 发送给对方。
        *   对方将 ICE 候选添加到 RTCPeerConnection 中。
            建立 P2P 连接
    4.  通过 ICE 协议匹配双方的网络地址，建立直接的 P2P 连接，音视频数据通过该连接传输。
        1.  音视频播放
        2.  浏览器 A/B 通过 ontrack 事件接收远程音视频流，并绑定到  元素播放。
6.  算法：有个AOE技能在坐标\[x,y]释放，会优先命中target数量的敌人，给出敌人坐标分布、技能释放坐标、能够命中的敌人数，请返回被命中的敌人坐标。
    ```javascript
    // 大根堆
    class MaxTree {
        constructor(size, target) {
            this.queue = [Infinity];
            this.target = target;
            this.size = size + 1;
        }
        add(coordinates) {
            const distance = this.getDistance(coordinates);
            const maxDistance = this.getDistance(this.queue[1]);
            if (this.queue.length >= this.size) {
                if (distance < maxDistance) {
                    return;
                }
                this.queue[1] = coordinates;
                this.downFloat(1);
            }
            this.queue.push(coordinates);
        }
        getDistance(coordinates) {
            const val = (coordinates[0] - this.target[0])**2 + (coordinates[1] - this.target[1])**2;
            return val;
        }
        downFloat(index) {
            // 0 1 2 3 4 5 6
            const left = index * 2;
            const right = index * 2 + 1;
            if (left >= this.queue.length) {
                return;
            }
            const distance = this.getDistance(this.queue[index]);
            const leftDistance = this.getDistance(this.queue[left]);
            const rightDistance = this.getDistance(this.queue[right]);
            if (distance > leftDistance && distance > rightDistance) {
                return;
            }
            if (leftDistance > rightDistance) {
                this.queue[index] = this.queue[left];
                this.queue[left] = coordinates;
                this.downFloat(left);
            } else {
                this.queue[index] = this.queue[right];
                this.queue[right] = coordinates;
                this.downFloat(right);
            }
        }
        pop() {
            const val = this.queue[1];
            this.queue[1] = this.queue[this.queue.length - 1];
            this.queue.pop();
            this.downFloat(1);
            return val;
        }
        upFloat(index) {
            if (index === 1) {
                return;
            }
            const parent = index >> 1;
            const distance = this.getDistance(this.queue[index]);
            const parentDistance = this.getDistance(this.queue[parent]);
            if (distance < parentDistance) {
                return;
            }
            this.queue[index] = this.queue[parent];
            this.queue[parent] = this.queue[index];
            this.upFloat(parent);
        }
    }
    ```

