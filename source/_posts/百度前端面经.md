---
title: 百度前端面经
date: 2025-08-08 22:10:34
tags: 
    - 前端
    - 面经
    - 百度
---
1.  flex：1

2.  导出的模块更新，怎么让开发无感升级（模块联邦）

    1.  启动服务：分别启动远程应用（通常在 `3001` 端口）和宿主应用（通常在 `3000` 端口）。
    2.  动态加载：当你在浏览器中访问宿主应用（`http://localhost:3000`）时，会发生：

        *   浏览器加载宿主应用的 `index.html` 和主要脚本。
        *   当代码执行到 `import('RemoteApp/Button')` 时，Webpack 会去配置的 URL（`http://localhost:3001/remoteEntry.js`） 加载远程应用的入口文件。
        *   `remoteEntry.js` 像一个清单，告诉宿主如何获取 `Button` 组件等暴露的模块。
        *   宿主然后加载 `Button` 组件的具体代码块。
        *   由于配置了 `shared: ['react']`，双方会协商使用同一个 `react` 实例，确保代码正确运行。
    3.  渲染组件：远程组件成功加载后，就会在宿主应用中渲染出来。
    4.  `requiredVersion`：这是版本控制的灵魂。它告诉 Webpack：“我这个模块/应用兼容哪个版本的依赖”。它可以是一个 `string`（如 `"^18.2.0"`），也可以是 `package.json` 中的版本。Webpack 使用这个信息来寻找所有应用共同接受的版本。
    5.  `singleton`：如果设置为 `true`，整个应用图（所有 Host 和 Remote）必须且只能使用一个实例。这对于 React、Vue、状态管理库等是必须的，因为多个实例会破坏上下文导致巨大错误。
    6.  `eager`：允许 Webpack 直接在当前应用的 bundle 中包含该依赖，而不是异步加载它。这牺牲了共享的优势（每个应用都打包了一份），但可以避免额外的网络请求和潜在的版本冲突。通常设为 `false`。
    7.  `strictVersion`：如果为 `true`，当协商出的版本不满足 `requiredVersion` 时，会发出警告，并且不会接受降级方案。通常与 `singleton: true` 一起使用，如果版本不匹配，宁愿让应用失败也不愿看到不可预测的行为。

3.  箭头函数的this指向

4.  position的可取值跟意思

5.  算法：一长串字符串计算式的加减乘除
